## Challenge Name: Hyper Loop
Category: Crypto
Points: 379
Solves: 105

Challenge Description: 
The author is aware that XOR alone is not sufficiently secure, but they have implemented a solution to address this issue. Use the provided Python script to rec over the original flag.

Format : Hero{flag}
Author : xanhacks

Artifact Files:
* [hyper_loop.py]()

### Approach

**1. <Question_1_description>?/flag1**

![img](<image_link>)

I was provided with this python file:
```python
from os import urandom


flag = bytearray(b"Hero{????????????}")
assert len(flag) == 18

for _ in range(32):
    for i, c in enumerate(urandom(6) * 3):
        flag[i] = flag[i] ^ c

print(f"{flag = }")


"""
$ python3 hyper_loop.py 
flag = bytearray(b'\x05p\x07MS\xfd4eFPw\xf9}%\x05\x03\x19\xe8')
"""
```

As a beginner, I used ChatGPT to explain the code to me and found out that a XOR encryption is done on the flag using the random bytes generated by the `urandom()` function.

Knowing that I had to get the original flag's character to decrypt the flag, I realised that the first 5 characters of the flag are known, that being `Hero{` and the last 1 character of the flag: `}`.

As such, due to it correlating to 6 characters = 6 bytes (? i dont really know how to explain my thinking), I reversed the XOR encryption on these 6 characters to obtain the 6 bytes from the encrypted flag in the comment.

```python
flag = bytearray(b'\x05p\x07MS\xfd4eFPw\xf9%\x05\x03\x19\xe8')
characters = bytearray(b'Hero{}')
urandombytes = [] 

for i in range(len(characters)):
    if i < 5:
        urandombytes.append(character[i]^flag[i])
    if i == 5:
        urandombytes.append(character[-1]^flag[-1])

print(urandombytes)
```

This gave me the 6 bytes used to encrypt the original flag which hence allowed me to decrypt the flag.

However, I tried:

```python
from os import urandom

character = bytearray(b"Hero{}")
flag = bytearray(b'\x05p\x07MS\xfd4eFPw\xf9}%\x05\x03\x19\xe8')
urandombytes = []

for _ in range(32):
    for i, c in enumerate([77,21,117,34,40,149] * 3):
        flag[i] = flag[i] ^ c

print(flag)
```
Which did not work because I did not need to iterate the decryption process 32 times which probably caused it to become encrypted again.

I had to ask ChatGPT for help with this as I didn't realise and therefore remove the first `for` loop, allowing me to get the flag!

`Hero{hyp3r_l00p!1}`


### Reflections
ChatGPT is a really good resource to have especially when you're trying to solve challenges. However you should not rely on it that much as it may deter you from thinking more into the challenge.
  

---
[Back to home](<link>)
